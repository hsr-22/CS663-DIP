\documentclass{article}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{fancyvrb}
\usepackage{enumitem}
\usepackage{matlab-prettifier}
\setlength{\parindent}{0pt}
\graphicspath{{../images/}}

% Code style
\lstset{
    frame=single,
    language=Matlab,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    breaklines=true,
    numbers=left,
    numberstyle=\tiny\color{gray},
    captionpos=b,
    showstringspaces=false,
}


\title{Image Compression Engine: Implementation and Analysis\\ \large{\textit{Course Project Report - CS663}}}
\author{Harsh $\vert$ Pranav $\vert$ Swayam} 

\begin{document}

\maketitle
\flushleft

\tableofcontents
\newpage

\begin{abstract}
This report describes the implementation of an image compression engine inspired by the JPEG algorithm. The implemented system performs discrete cosine transform (DCT) on image patches, quantizes the coefficients, applies Huffman coding, and writes the compressed data to a file. A decoding module reconstructs the image for analysis. Results for multiple images are analyzed using metrics like RMSE and BPP across varying quality factors. The project's merits and limitations are also discussed.
\end{abstract}

\section{Introduction}
Image compression is a critical area in digital image processing, where the objective is to reduce the size of image files without significant loss of quality. The JPEG compression standard achieves this using techniques such as Discrete Cosine Transform (DCT), quantization, and entropy coding. This project implements a simplified version of the JPEG compression algorithm, evaluates its performance, and analyzes its strengths and weaknesses.

\section{Problem Statement}
The objective of this project is to:
\begin{itemize}
    \item Implement a simplified JPEG-like compression algorithm for grayscale images.
    \item Evaluate the algorithm's performance by calculating metrics such as Root Mean Square Error (RMSE) and Bits Per Pixel (BPP).
    \item Generate reconstructed images for various quality factors and analyze the trade-off between compression ratio and image quality.
\end{itemize}

\section{Algorithm Description}
The implemented algorithm consists of the following steps:
\begin{enumerate}
    \item \textbf{Discrete Cosine Transform (DCT):} 
    The input image is divided into non-overlapping $8 \times 8$ blocks, and the 2D DCT is applied to each block to transform the image into the frequency domain.
    
    \item \textbf{Quantization:}
    A quantization table is used to reduce the precision of the DCT coefficients. The quantization table values are scaled based on a user-defined quality factor.
    
    \item \textbf{Run-Length Encoding (RLE):}
    The quantized DCT coefficients are scanned in a zigzag order, and sequences of zero coefficients are encoded efficiently using run-length encoding.
    
    \item \textbf{Huffman Encoding:}
    The RLE output is further compressed using Huffman encoding, which replaces frequently occurring patterns with shorter codes.
    
    \item \textbf{Decoding:}
    The compressed data is decoded by reversing the Huffman and RLE encoding processes, followed by inverse quantization and the Inverse Discrete Cosine Transform (IDCT).
    
    \item \textbf{Reconstruction:}
    The reconstructed image is generated and compared with the original image to calculate the RMSE and evaluate the compression ratio.
\end{enumerate}

\section{Dataset Description}
The algorithm was tested on a dataset of grayscale BMP and TIF images, converted from color images if necessary. Each image had varying dimensions and complexity to evaluate the algorithm's robustness. The dataset included:
\begin{itemize}
    \item \href{https://www.kaggle.com/datasets/sbilab/segpc2021dataset}{SegPC-2021: Segmentation of Multiple Myeloma Plasma Cells in Microscopic Images}.
    \item "Standard" test images (a set of images found frequently in the literature) from \href{https://www.imageprocessingplace.com/root_files_V3/image_databases.htm}{Image Processing Place}.
\end{itemize}

The images were processed for five quality factors: $10$, $20$, $50$, $75$, and $90$.

\section{Results and Analysis}


\subsection{Discussion}
The algorithm performs well in reducing file size while maintaining acceptable image quality. However:
\begin{itemize}
    \item \textbf{Strengths:} 
    \begin{itemize}
        \item Efficient use of frequency domain for compression.
        \item Effective reduction in redundancy using RLE and Huffman encoding.
        \item Customizable quality factor allows flexible trade-offs.
    \end{itemize}
    \item \textbf{Weaknesses:}
    \begin{itemize}
        \item High computational overhead due to block-wise DCT and Huffman encoding.
        \item Loss of detail in high-frequency regions at low quality factors.
        \item Limited optimization for real-time applications.
    \end{itemize}
\end{itemize}

\section{Conclusion}
The implemented JPEG-like compression algorithm successfully demonstrates the principles of lossy image compression. The RMSE and BPP results confirm the effectiveness of the approach in achieving a balance between image quality and compression ratio. Future work could involve:
\begin{itemize}
    \item Extending the implementation to color images.
    \item Incorporating advanced entropy coding techniques like arithmetic coding.
    \item Optimizing the algorithm for real-time processing.
\end{itemize}

\section{Introduction}
Image compression is a critical aspect of digital storage and transmission. The JPEG algorithm achieves significant compression by exploiting redundancies in image data while maintaining perceptual quality. This project implements the essential components of JPEG compression on grayscale images and evaluates its performance using RMSE and BPP metrics.

\section{Code Implementation and Explanation}
This section explains the MATLAB code for JPEG-like image compression. The steps include loading an image, applying DCT, quantization, Huffman encoding, and reconstruction. RMSE and BPP are calculated to evaluate compression performance.

\subsection{Code for JPEG-Like Compression}

\begin{lstlisting}[caption=Image Compression Code, label=lst:compression_code]
% Set image directory path
image_dir = '../images/';
...
% Create a new figure for the second plot
figure;
plot(bpp_values, rmse_values, '-o');
xlabel('Bits Per Pixel (BPP)');
ylabel('RMSE');
title('RMSE vs. BPP');
\end{lstlisting}

\subsection{Explanation of Code Sections}

\paragraph{1. Reading the Image:} 
The image is loaded and converted to a double format for accurate DCT calculations. The block size for partitioning the image into non-overlapping patches is set to 8x8.

\begin{lstlisting}[caption=Reading the Image]
image = imread(fullfile(image_dir, 'kodak24.png'));
image = double(image);  % Convert to double for DCT
blockSize = [8 8];
\end{lstlisting}

\paragraph{2. Applying DCT:}
The blockproc function applies 2D DCT to each 8x8 block of the image. This step transforms spatial information into frequency components.

\begin{lstlisting}[caption=Applying 2D DCT]
dct_image = blockproc(image, blockSize, @(block) dct2(block.data));
\end{lstlisting}

\paragraph{3. Quantization:}
Quantization reduces the precision of the DCT coefficients using a predefined quantization matrix. A higher scaling factor reduces quality but increases compression.

\begin{lstlisting}[caption=Quantization Step]
quantization_matrix = [
    16, 11, 10, 16, 24, 40, 51, 61;
    12, 12, 14, 19, 26, 58, 60, 55;
    ... % truncated for brevity
];
quantized_image = blockproc(dct_image, blockSize, @(block) round(block.data ./ quantization_matrix));
\end{lstlisting}

\paragraph{4. Huffman Encoding:}
The quantized coefficients are flattened and encoded using Huffman coding to minimize storage. The encoded data and metadata are saved to a file.

\begin{lstlisting}[caption=Huffman Encoding and Saving]
symbols = unique(quantized_image(:));
counts = histcounts(quantized_image(:), [symbols; max(symbols)+1]);
[dict, avglen] = huffmandict(symbols, counts / numel(quantized_image));
huff_encoded_image = huffmanenco(quantized_image(:), dict);
save('compressed_image.mat', 'huff_encoded_image', 'quantization_matrix', 'dict', 'size_of_image', '-v7.3');
\end{lstlisting}

\paragraph{5. Reconstruction:}
The compressed data is decoded, dequantized, and the inverse DCT is applied to reconstruct the image.

\begin{lstlisting}[caption=Reconstruction]
decoded_data = huffmandeco(huff_encoded_image, dict);
quantized_image = reshape(decoded_data, size_of_image);
dequantized_image = blockproc(quantized_image, blockSize, @(block) block.data .* quantization_matrix);
reconstructed_image = blockproc(dequantized_image, blockSize, @(block) idct2(block.data));
\end{lstlisting}

\paragraph{6. Calculating Metrics:}
RMSE and BPP are calculated to analyze compression quality. RMSE measures error between original and reconstructed images, while BPP indicates compression efficiency.

\begin{lstlisting}[caption=Metrics Calculation]
rmse = sqrt(mean((double(image) - double(reconstructed_image)).^2, 'all'));
bpp = numel(huff_encoded_image) / numel(image);  % Bits per pixel
\end{lstlisting}

\paragraph{7. Quality Factor Analysis:}
A loop adjusts the quantization matrix for different quality factors, recalculating RMSE and BPP for each iteration. A plot of RMSE vs. BPP summarizes the trade-offs.

\begin{lstlisting}[caption=Quality Factor Analysis]
quality_factors = 10:10:100;
for idx = 1:length(quality_factors)
    % Adjust quantization matrix based on quality factor
    scaled_quantization_matrix = round(quantization_matrix * (100 / quality_factors(idx)));
    ...
end
\end{lstlisting}

\section{Results}
% \begin{figure}[h!]
%     \centering
%     \includegraphics[width=0.8\textwidth]{RMSEvsBPP.png}
%     \caption{RMSE vs. BPP plot for varying quality factors.}
%     \label{fig:rmse_bpp}
% \end{figure}

% \begin{figure}[h!]
%     \centering
%     \includegraphics[width=0.4\textwidth]{untitled3.png}
%     \includegraphics[width=0.4\textwidth]{untitled3.jpg}
%     \caption{Original vs. Reconstructed Image.}
%     \label{fig:reconstructed_images}
% \end{figure}
\newpage
\section{Discussion}
\subsection{Strengths}
\begin{itemize}
    \item Efficient implementation of JPEG components.
    \item Accurate reconstruction of images at moderate quality factors.
\end{itemize}

\subsection{Limitations}
\begin{itemize}
    \item Compression artifacts visible at low quality factors.
    \item Fixed quantization matrix limits adaptability.
\end{itemize}


\section{Conclusion}
The MATLAB implementation effectively demonstrates JPEG-like compression. By varying quality factors, the trade-off between compression efficiency (BPP) and reconstruction quality (RMSE) was analyzed. Future improvements can include adaptive quantization and optimizing encoding schemes.



\end{document}



\end{document}
